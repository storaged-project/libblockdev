#include <glib.h>
#include <glib-object.h>
#include <uuid/uuid.h>
#include <blockdev/utils.h>

#ifndef BD_NVME_API
#define BD_NVME_API

GQuark bd_nvme_error_quark (void) {
    return g_quark_from_static_string ("g-bd-nvme-error-quark");
}

#define BD_NVME_ERROR bd_nvme_error_quark ()
/* BpG-skip */
/**
 * BDNVMEError:
 * @BD_NVME_ERROR_TECH_UNAVAIL: NVMe support not available.
 * @BD_NVME_ERROR_FAILED: General error.
 * @BD_NVME_ERROR_SC_GENERIC: Generic NVMe Command Status Code.
 * @BD_NVME_ERROR_SC_CMD_SPECIFIC: NVMe Command Specific error.
 * @BD_NVME_ERROR_SC_MEDIA: Media and Data Integrity Errors: media specific errors that occur in the NVM or data integrity type errors.
 * @BD_NVME_ERROR_SC_PATH: Path related error.
 * @BD_NVME_ERROR_SC_VENDOR_SPECIFIC: NVMe Vendor specific error.
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_ERROR_TECH_UNAVAIL,
    BD_NVME_ERROR_FAILED,
    BD_NVME_ERROR_SC_GENERIC,
    BD_NVME_ERROR_SC_CMD_SPECIFIC,
    BD_NVME_ERROR_SC_MEDIA,
    BD_NVME_ERROR_SC_PATH,
    BD_NVME_ERROR_SC_VENDOR_SPECIFIC,
} BDNVMEError;

typedef enum {
    BD_NVME_TECH_NVME = 0,
    BD_NVME_TECH_NVMEOF,
} BDNVMETech;

typedef enum {
    BD_NVME_TECH_MODE_INFO         = 1 << 0,
    BD_NVME_TECH_MODE_NAMESPACE    = 1 << 1,
    BD_NVME_TECH_MODE_INITIATOR    = 1 << 2,
} BDNVMETechMode;


/* BpG-skip */
/**
 * BDNVMEControllerFeature:
 * @BD_NVME_CTRL_FEAT_MULTIPORT: if set, then the NVM subsystem may contain more than one NVM subsystem port, otherwise it's single-port only.
 * @BD_NVME_CTRL_FEAT_MULTICTRL: if set, then the NVM subsystem may contain two or more controllers, otherwise contains only single controller.
 * @BD_NVME_CTRL_FEAT_SRIOV: if set, then the controller is associated with an SR-IOV Virtual Function, otherwise it's associated with a PCI Function or a Fabrics connection.
 * @BD_NVME_CTRL_FEAT_ANA_REPORTING: indicates that the NVM subsystem supports Asymmetric Namespace Access (ANA) Reporting.
 * @BD_NVME_CTRL_FEAT_FORMAT: indicates that the controller supports the Format NVM command.
 * @BD_NVME_CTRL_FEAT_FORMAT_ALL_NS: if set, then a format (excluding secure erase) of any namespace results in a format of all namespaces
 *                                   in an NVM subsystem with all namespaces in an NVM subsystem configured with the same attributes.
 *                                   If not set, then the controller supports format on a per namespace basis.
 * @BD_NVME_CTRL_FEAT_NS_MGMT: indicates that the controller supports the Namespace Management and Attachment capability.
 * @BD_NVME_CTRL_FEAT_SELFTEST: indicates that the controller supports the Device Self-test command.
 * @BD_NVME_CTRL_FEAT_SELFTEST_SINGLE: indicates that the NVM subsystem supports only one device self-test operation in progress at a time.
 * @BD_NVME_CTRL_FEAT_SANITIZE_CRYPTO: indicates that the controller supports the Crypto Erase sanitize operation.
 * @BD_NVME_CTRL_FEAT_SANITIZE_BLOCK: indicates that the controller supports the Block Erase sanitize operation.
 * @BD_NVME_CTRL_FEAT_SANITIZE_OVERWRITE: indicates that the controller supports the Overwrite sanitize operation.
 * @BD_NVME_CTRL_FEAT_SECURE_ERASE_ALL_NS: if set, then any secure erase performed as part of a format operation
 *                                         results in a secure erase of all namespaces in the NVM subsystem. If not set,
 *                                         then any secure erase performed as part of a format results in a secure erase
 *                                         of the particular namespace specified.
 * @BD_NVME_CTRL_FEAT_SECURE_ERASE_CRYPTO: indicates that the cryptographic erase is supported.
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_CTRL_FEAT_MULTIPORT           = 1 << 0,
    BD_NVME_CTRL_FEAT_MULTICTRL           = 1 << 1,
    BD_NVME_CTRL_FEAT_SRIOV               = 1 << 2,
    BD_NVME_CTRL_FEAT_ANA_REPORTING       = 1 << 3,
    BD_NVME_CTRL_FEAT_FORMAT              = 1 << 4,
    BD_NVME_CTRL_FEAT_FORMAT_ALL_NS       = 1 << 5,
    BD_NVME_CTRL_FEAT_NS_MGMT             = 1 << 6,
    BD_NVME_CTRL_FEAT_SELFTEST            = 1 << 7,
    BD_NVME_CTRL_FEAT_SELFTEST_SINGLE     = 1 << 8,
    BD_NVME_CTRL_FEAT_SANITIZE_CRYPTO     = 1 << 9,
    BD_NVME_CTRL_FEAT_SANITIZE_BLOCK      = 1 << 10,
    BD_NVME_CTRL_FEAT_SANITIZE_OVERWRITE  = 1 << 11,
    BD_NVME_CTRL_FEAT_SECURE_ERASE_ALL_NS = 1 << 12,
    BD_NVME_CTRL_FEAT_SECURE_ERASE_CRYPTO = 1 << 13,
} BDNVMEControllerFeature;

#define BD_NVME_TYPE_CONTROLLER_INFO (bd_nvme_controller_info_get_type ())
GType bd_nvme_controller_info_get_type ();

/**
 * BDNVMEControllerInfo:
 * @ctrl_id: Controller ID, the NVM subsystem unique controller identifier associated with the controller.
 * @fguid: FRU GUID, a 128-bit value that is globally unique for a given Field Replaceable Unit.
 * @features: features and capabilities present for this controller, see #BDNVMEControllerFeature.
 * @selftest_ext_time: Extended Device Self-test Time, if #BD_NVME_CTRL_FEAT_SELFTEST is supported then this field
 *                     indicates the nominal amount of time in one minute units that the controller takes
 *                     to complete an extended device self-test operation when in power state 0.
 * @hmb_pref_size: Host Memory Buffer Preferred Size indicates the preferred size that the host
 *                 is requested to allocate for the Host Memory Buffer feature in bytes.
 * @hmb_min_size: Host Memory Buffer Minimum Size indicates the minimum size that the host
 *                is requested to allocate for the Host Memory Buffer feature in bytes.
 * @size_total: Total NVM Capacity in the NVM subsystem in bytes.
 * @size_unalloc: Unallocated NVM Capacity in the NVM subsystem in bytes.
 * @num_namespaces: Maximum Number of Allowed Namespaces supported by the NVM subsystem.
 * @subsysnqn: NVM Subsystem NVMe Qualified Name, UTF-8 null terminated string.
 */
typedef struct BDNVMEControllerInfo {
    guint16 ctrl_id;
    gchar *fguid;
    guint64 features;
    gint selftest_ext_time;
    guint64 hmb_pref_size;
    guint64 hmb_min_size;
    guint64 size_total;
    guint64 size_unalloc;
    gint num_namespaces;
    gchar *subsysnqn;
} BDNVMEControllerInfo;

/**
 * bd_nvme_controller_info_free: (skip)
 * @info: (allow-none): %BDNVMEControllerInfo to free
 *
 * Frees @info.
 */
void bd_nvme_controller_info_free (BDNVMEControllerInfo *info) {
    if (info == NULL)
        return;

    g_free (info->fguid);
    g_free (info->subsysnqn);
    g_free (info);
}

/**
 * bd_nvme_controller_info_copy: (skip)
 * @info: (allow-none): %BDNVMEControllerInfo to copy
 *
 * Creates a new copy of @info.
 */
BDNVMEControllerInfo * bd_nvme_controller_info_copy (BDNVMEControllerInfo *info) {
    BDNVMEControllerInfo *new_info;

    if (info == NULL)
        return NULL;

    new_info = g_new0 (BDNVMEControllerInfo, 1);
    memcpy (new_info, info, sizeof (BDNVMEControllerInfo));
    new_info->fguid = g_strdup (info->fguid);
    new_info->subsysnqn = g_strdup (info->subsysnqn);

    return new_info;
}

GType bd_nvme_controller_info_get_type () {
    static GType type = 0;

    if (G_UNLIKELY (type == 0)) {
        type = g_boxed_type_register_static ("BDNVMEControllerInfo",
                                             (GBoxedCopyFunc) bd_nvme_controller_info_copy,
                                             (GBoxedFreeFunc) bd_nvme_controller_info_free);
    }
    return type;
}


/* BpG-skip */
/**
 * BDNVMELBAFormatRelativePerformance:
 * Performance index of the LBA format relative to other LBA formats supported by the controller.
 * @BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_UNKNOWN: Unknown relative performance index.
 * @BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_BEST: Best performance.
 * @BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_BETTER: Better performance.
 * @BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_GOOD: Good performance.
 * @BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_DEGRADED: Degraded performance.
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_UNKNOWN = 0,
    BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_BEST = 1,
    BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_BETTER = 2,
    BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_GOOD = 3,
    BD_NVME_LBA_FORMAT_RELATIVE_PERFORMANCE_DEGRADED = 4
} BDNVMELBAFormatRelativePerformance;

#define BD_NVME_TYPE_LBA_FORMAT (bd_nvme_lba_format_get_type ())
GType bd_nvme_lba_format_get_type ();

/**
 * BDNVMELBAFormat:
 * Namespace LBA Format Data Structure.
 * @data_size: LBA data size (i.e. a sector size) in bytes.
 * @relative_performance: Relative Performance index, see #BDNVMELBAFormatRelativePerformance.
 */
typedef struct BDNVMELBAFormat {
    guint16 data_size;
    BDNVMELBAFormatRelativePerformance relative_performance;
} BDNVMELBAFormat;

/**
 * bd_nvme_lba_format_free: (skip)
 * @fmt: (allow-none): %BDNVMELBAFormat to free
 *
 * Frees @fmt.
 */
void bd_nvme_lba_format_free (BDNVMELBAFormat *fmt) {
    g_free (fmt);
}

/**
 * bd_nvme_lba_format_copy: (skip)
 * @fmt: (allow-none): %BDNVMELBAFormat to copy
 *
 * Creates a new copy of @fmt.
 */
BDNVMELBAFormat * bd_nvme_lba_format_copy (BDNVMELBAFormat *fmt) {
    BDNVMELBAFormat *new_fmt;

    if (fmt == NULL)
        return NULL;

    new_fmt = g_new0 (BDNVMELBAFormat, 1);
    new_fmt->data_size = fmt->data_size;
    new_fmt->relative_performance = fmt->relative_performance;

    return new_fmt;
}

GType bd_nvme_lba_format_get_type () {
    static GType type = 0;

    if (G_UNLIKELY (type == 0)) {
        type = g_boxed_type_register_static ("BDNVMELBAFormat",
                                             (GBoxedCopyFunc) bd_nvme_lba_format_copy,
                                             (GBoxedFreeFunc) bd_nvme_lba_format_free);
    }
    return type;
}

/* BpG-skip */
/**
 * BDNVMENamespaceFeature:
 * @BD_NVME_NS_FEAT_THIN: indicates that the namespace supports thin provisioning. Specifically, the Namespace Capacity
 *                        reported may be less than the Namespace Size.
 * @BD_NVME_NS_FEAT_MULTIPATH_SHARED: indicates the capability to attach the namespace to two or more controllers
 *                                    in the NVM subsystem concurrently.
 * @BD_NVME_NS_FEAT_FORMAT_PROGRESS: indicates the capability to report the percentage of the namespace
 *                                   that remains to be formatted.
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_NS_FEAT_THIN             = 1 << 0,
    BD_NVME_NS_FEAT_MULTIPATH_SHARED = 1 << 1,
    BD_NVME_NS_FEAT_FORMAT_PROGRESS  = 1 << 2,
} BDNVMENamespaceFeature;

#define BD_NVME_TYPE_NAMESPACE_INFO (bd_nvme_namespace_info_get_type ())
GType bd_nvme_namespace_info_get_type ();

/**
 * BDNVMENamespaceInfo:
 * @nsid: The Namespace Identifier (NSID).
 * @eui64: IEEE Extended Unique Identifier: a 64-bit IEEE Extended Unique Identifier (EUI-64)
 *         that is globally unique and assigned to the namespace when the namespace is created.
 *         Remains fixed throughout the life of the namespace and is preserved across namespace
 *         and controller operations.
 * @nguid: Namespace Globally Unique Identifier: a 128-bit value that is globally unique and
 *         assigned to the namespace when the namespace is created. Remains fixed throughout
 *         the life of the namespace and is preserved across namespace and controller operations.
 * @uuid: Namespace 128-bit Universally Unique Identifier (UUID) as specified in RFC 4122.
 * @nsize: Namespace Size: total size of the namespace in logical blocks. The number of logical blocks
 *         is based on the formatted LBA size (see @current_lba_format).
 * @ncap: Namespace Capacity: maximum number of logical blocks that may be allocated in the namespace
 *        at any point in time. The number of logical blocks is based on the formatted LBA size (see @current_lba_format).
 * @nuse: Namespace Utilization: current number of logical blocks allocated in the namespace.
 *        This field is smaller than or equal to the Namespace Capacity. The number of logical
 *        blocks is based on the formatted LBA size (see @current_lba_format).
 * @features: features and capabilities present for this namespace, see #BDNVMENamespaceFeature.
 * @format_progress_remaining: The percentage value remaining of a format operation in progress.
 * @write_protected: %TRUE if the namespace is currently write protected and all write access to the namespace shall fail.
 * @lba_formats: (array zero-terminated=1) (element-type BDNVMELBAFormat): A list of supported LBA Formats.
 * @current_lba_format: A LBA Format currently used for the namespace. Contains zeroes in case of
 *                      an invalid or no supported LBA Format reported.
 */
typedef struct BDNVMENamespaceInfo {
    guint32 nsid;
    gchar *eui64;
    gchar *uuid;
    gchar *nguid;
    guint64 nsize;
    guint64 ncap;
    guint64 nuse;
    guint64 features;
    guint8 format_progress_remaining;
    gboolean write_protected;
    BDNVMELBAFormat **lba_formats;
    BDNVMELBAFormat current_lba_format;
} BDNVMENamespaceInfo;

/**
 * bd_nvme_namespace_info_free: (skip)
 * @info: (allow-none): %BDNVMENamespaceInfo to free
 *
 * Frees @info.
 */
void bd_nvme_namespace_info_free (BDNVMENamespaceInfo *info) {
    BDNVMELBAFormat **lba_formats;

    if (info == NULL)
        return;

    g_free (info->eui64);
    g_free (info->uuid);
    g_free (info->nguid);

    for (lba_formats = info->lba_formats; lba_formats && *lba_formats; lba_formats++)
        bd_nvme_lba_format_free (*lba_formats);
    g_free (info->lba_formats);
    g_free (info);
}

/**
 * bd_nvme_namespace_info_copy: (skip)
 * @info: (allow-none): %BDNVMENamespaceInfo to copy
 *
 * Creates a new copy of @info.
 */
BDNVMENamespaceInfo * bd_nvme_namespace_info_copy (BDNVMENamespaceInfo *info) {
    BDNVMENamespaceInfo *new_info;
    BDNVMELBAFormat **lba_formats;
    GPtrArray *ptr_array;

    if (info == NULL)
        return NULL;

    new_info = g_new0 (BDNVMENamespaceInfo, 1);
    memcpy (new_info, info, sizeof (BDNVMENamespaceInfo));
    new_info->eui64 = g_strdup (info->eui64);
    new_info->uuid = g_strdup (info->uuid);
    new_info->nguid = g_strdup (info->nguid);

    ptr_array = g_ptr_array_new ();
    for (lba_formats = info->lba_formats; lba_formats && *lba_formats; lba_formats++)
        g_ptr_array_add (ptr_array, bd_nvme_lba_format_copy (*lba_formats));
    g_ptr_array_add (ptr_array, NULL);
    new_info->lba_formats = (BDNVMELBAFormat **) g_ptr_array_free (ptr_array, FALSE);

    return new_info;
}

GType bd_nvme_namespace_info_get_type () {
    static GType type = 0;

    if (G_UNLIKELY (type == 0)) {
        type = g_boxed_type_register_static ("BDNVMENamespaceInfo",
                                             (GBoxedCopyFunc) bd_nvme_namespace_info_copy,
                                             (GBoxedFreeFunc) bd_nvme_namespace_info_free);
    }
    return type;
}


/* BpG-skip */
/**
 * BDNVMESmartCriticalWarning:
 * @BD_NVME_SMART_CRITICAL_WARNING_SPARE: the available spare capacity has fallen below the threshold.
 * @BD_NVME_SMART_CRITICAL_WARNING_TEMPERATURE: a temperature is either greater than or equal to an over temperature threshold;
 *                                              or less than or equal to an under temperature threshold.
 * @BD_NVME_SMART_CRITICAL_WARNING_DEGRADED: the NVM subsystem reliability has been degraded due to  significant media
 *                                           related errors or any internal error that degrades NVM subsystem reliability.
 * @BD_NVME_SMART_CRITICAL_WARNING_READONLY: all of the media has been placed in read only mode. Unrelated to the write
 *                                           protection state of a namespace.
 * @BD_NVME_SMART_CRITICAL_WARNING_VOLATILE_MEM: the volatile memory backup device has failed. Valid only if the controller
 *                                               has a volatile memory backup solution.
 * @BD_NVME_SMART_CRITICAL_WARNING_PMR_READONLY: Persistent Memory Region has become read-only or unreliable.
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_SMART_CRITICAL_WARNING_SPARE        = 1 << 0,
    BD_NVME_SMART_CRITICAL_WARNING_TEMPERATURE  = 1 << 1,
    BD_NVME_SMART_CRITICAL_WARNING_DEGRADED     = 1 << 2,
    BD_NVME_SMART_CRITICAL_WARNING_READONLY     = 1 << 3,
    BD_NVME_SMART_CRITICAL_WARNING_VOLATILE_MEM = 1 << 4,
    BD_NVME_SMART_CRITICAL_WARNING_PMR_READONLY = 1 << 5,
} BDNVMESmartCriticalWarning;

#define BD_NVME_TYPE_SMART_LOG (bd_nvme_smart_log_get_type ())
GType bd_nvme_smart_log_get_type ();

/**
 * BDNVMESmartLog:
 * @critical_warning: critical warnings for the state of the controller, see #BDNVMESmartCriticalWarning.
 * @avail_spare: Available Spare: a normalized percentage (0% to 100%) of the remaining spare capacity available.
 * @spare_thresh: Available Spare Threshold: a normalized percentage (0% to 100%) of the available spare threshold.
 * @percent_used: Percentage Used: a vendor specific estimate of the percentage drive life used based on the
 *                actual usage and the manufacturer's prediction. A value of %100 indicates that the estimated
 *                endurance has been consumed, but may not indicate an NVM subsystem failure.
 *                The value is allowed to exceed %100.
 * @total_data_read: An estimated calculation of total data read in bytes based on calculation of data
 *                   units read from the host. A value of %0 indicates that the number of Data Units Read
 *                   is not reported.
 * @total_data_written: An estimated calculation of total data written in bytes based on calculation
 *                      of data units written by the host. A value of %0 indicates that the number
 *                      of Data Units Written is not reported.
 * @ctrl_busy_time: Amount of time the controller is busy with I/O commands, reported in minutes.
 * @power_cycles: The number of power cycles.
 * @power_on_hours: The number of power-on hours, excluding a non-operational power state.
 * @unsafe_shutdowns: The number of unsafe shutdowns as a result of a Shutdown Notification not received prior to loss of power.
 * @media_errors: Media and Data Integrity Errors: the number of occurrences where the controller detected
 *                an unrecovered data integrity error (e.g. uncorrectable ECC, CRC checksum failure, or LBA tag mismatch).
 * @num_err_log_entries: Number of Error Information Log Entries: the number of Error Information log
 *                       entries over the life of the controller.
 * @temperature: Composite Temperature: temperature in degrees Celsius that represents the current composite
 *               temperature of the controller and associated namespaces or %-273 when not applicable.
 * @temp_sensors: Temperature Sensor 1-8: array of the current temperature reported by temperature sensors
 *                1-8 in degrees Celsius or %-273 when the particular sensor is not available.
 * @wctemp: Warning Composite Temperature Threshold (WCTEMP): indicates the minimum Composite Temperature (@temperature)
 *          value that indicates an overheating condition during which controller operation continues.
 *          A value of %0 indicates that no warning temperature threshold value is reported by the controller.
 * @cctemp: Critical Composite Temperature Threshold (CCTEMP): indicates the minimum Composite Temperature (@temperature)
 *          value that indicates a critical overheating condition (e.g., may prevent continued normal operation,
 *          possibility of data loss, automatic device shutdown, extreme performance throttling, or permanent damage).
 *          A value of %0 indicates that no critical temperature threshold value is reported by the controller.
 * @warning_temp_time: Warning Composite Temperature Time: the amount of time in minutes that the Composite Temperature (@temperature)
 *                     is greater than or equal to the Warning Composite Temperature Threshold (@wctemp) and less than the
 *                     Critical Composite Temperature Threshold (@cctemp).
 * @critical_temp_time: Critical Composite Temperature Time: the amount of time in minutes that the Composite Temperature (@temperature)
 *                      is greater than or equal to the Critical Composite Temperature Threshold (@cctemp).
 */
typedef struct BDNVMESmartLog {
    guint critical_warning;
    guint8 avail_spare;
    guint8 spare_thresh;
    guint8 percent_used;
    guint64 total_data_read;
    guint64 total_data_written;
    guint64 ctrl_busy_time;
    guint64 power_cycles;
    guint64 power_on_hours;
    guint64 unsafe_shutdowns;
    guint64 media_errors;
    guint64 num_err_log_entries;
    gint temperature;
    gint temp_sensors[8];
    guint wctemp;
    guint cctemp;
    guint warning_temp_time;
    guint critical_temp_time;
} BDNVMESmartLog;

/**
 * bd_nvme_smart_log_free: (skip)
 * @log: (allow-none): %BDNVMESmartLog to free
 *
 * Frees @log.
 */
void bd_nvme_smart_log_free (BDNVMESmartLog *log) {
    g_free (log);
}

/**
 * bd_nvme_smart_log_copy: (skip)
 * @log: (allow-none): %BDNVMESmartLog to copy
 *
 * Creates a new copy of @log.
 */
BDNVMESmartLog * bd_nvme_smart_log_copy (BDNVMESmartLog *log) {
    BDNVMESmartLog *new_log;

    if (log == NULL)
        return NULL;

    new_log = g_new0 (BDNVMESmartLog, 1);
    memcpy (new_log, log, sizeof (BDNVMESmartLog));

    return new_log;
}

GType bd_nvme_smart_log_get_type () {
    static GType type = 0;

    if (G_UNLIKELY (type == 0)) {
        type = g_boxed_type_register_static ("BDNVMESmartLog",
                                             (GBoxedCopyFunc) bd_nvme_smart_log_copy,
                                             (GBoxedFreeFunc) bd_nvme_smart_log_free);
    }
    return type;
}


/* BpG-skip */
/**
 * BDNVMETransportType:
 * Transport Type.
 * @BD_NVME_TRANSPORT_TYPE_UNSPECIFIED: Not indicated
 * @BD_NVME_TRANSPORT_TYPE_RDMA: RDMA Transport
 * @BD_NVME_TRANSPORT_TYPE_FC: Fibre Channel Transport
 * @BD_NVME_TRANSPORT_TYPE_TCP: TCP Transport
 * @BD_NVME_TRANSPORT_TYPE_LOOP: Intra-host Transport (loopback)
 */
/* BpG-skip-end */
typedef enum {
    BD_NVME_TRANSPORT_TYPE_UNSPECIFIED = 0,
    BD_NVME_TRANSPORT_TYPE_RDMA        = 1,
    BD_NVME_TRANSPORT_TYPE_FC          = 2,
    BD_NVME_TRANSPORT_TYPE_TCP         = 3,
    BD_NVME_TRANSPORT_TYPE_LOOP        = 254
} BDNVMETransportType;

#define BD_NVME_TYPE_ERROR_LOG_ENTRY (bd_nvme_error_log_entry_get_type ())
GType bd_nvme_error_log_entry_get_type ();

/**
 * BDNVMEErrorLogEntry:
 * @error_count: internal error counter, a unique identifier for the error.
 * @command_id: the Command Identifier of the command that the error is associated with or %0xffff if the error is not specific to a particular command.
 * @command_specific: Command Specific Information specific to @command_id.
 * @command_status: the Status code for the command that completed.
 * @command_error: translated command error in the BD_NVME_ERROR domain or %NULL in case @command_status indicates success.
 * @lba: the first LBA that experienced the error condition.
 * @nsid: the NSID of the namespace that the error is associated with.
 * @transport_type: type of the transport associated with the error.
 */
typedef struct BDNVMEErrorLogEntry {
    guint64 error_count;
    guint16 command_id;
    guint64 command_specific;
    guint16 command_status;
    GError *command_error;
    guint64 lba;
    guint32 nsid;
    BDNVMETransportType transport_type;
} BDNVMEErrorLogEntry;

/**
 * bd_nvme_error_log_entry_free: (skip)
 * @entry: (allow-none): %BDNVMEErrorLogEntry to free
 *
 * Frees @entry.
 */
void bd_nvme_error_log_entry_free (BDNVMEErrorLogEntry *entry) {
    if (entry == NULL)
        return;

    g_error_free (entry->command_error);
    g_free (entry);
}

/**
 * bd_nvme_error_log_entry_copy: (skip)
 * @entry: (allow-none): %BDNVMEErrorLogEntry to copy
 *
 * Creates a new copy of @entry.
 */
BDNVMEErrorLogEntry * bd_nvme_error_log_entry_copy (BDNVMEErrorLogEntry *entry) {
    BDNVMEErrorLogEntry *new_entry;

    if (entry == NULL)
        return NULL;

    new_entry = g_new0 (BDNVMEErrorLogEntry, 1);
    memcpy (new_entry, entry, sizeof (BDNVMEErrorLogEntry));
    new_entry->command_error = g_error_copy (entry->command_error);

    return new_entry;
}

GType bd_nvme_error_log_entry_get_type () {
    static GType type = 0;

    if (G_UNLIKELY (type == 0)) {
        type = g_boxed_type_register_static ("BDNVMEErrorLogEntry",
                                             (GBoxedCopyFunc) bd_nvme_error_log_entry_copy,
                                             (GBoxedFreeFunc) bd_nvme_error_log_entry_free);
    }
    return type;
}


/**
 * bd_nvme_get_controller_info:
 * @device: a NVMe controller device (e.g. /dev/nvme0)
 * @error: (out): place to store error (if any)
 *
 * Retrieves information about the NVMe controller (the Identify Controller command)
 * as specified by the @device block device path.
 *
 * Returns: (transfer full): information about given controller or %NULL in case of an error (with @error set).
 *
 * Tech category: %BD_NVME_TECH_NVME-%BD_NVME_TECH_MODE_INFO
 */
BDNVMEControllerInfo * bd_nvme_get_controller_info (const gchar *device, GError **error);

/**
 * bd_nvme_get_namespace_info:
 * @device: a NVMe namespace device (e.g. /dev/nvme0n1)
 * @error: (out): place to store error (if any)
 *
 * Retrieves information about the NVMe namespace (the Identify Namespace command)
 * as specified by the @device block device path.
 *
 * Returns: (transfer full): information about given namespace or %NULL in case of an error (with @error set).
 *
 * Tech category: %BD_NVME_TECH_NVME-%BD_NVME_TECH_MODE_INFO
 */
BDNVMENamespaceInfo * bd_nvme_get_namespace_info (const gchar *device, GError **error);

/**
 * bd_nvme_get_smart_log:
 * @device: a NVMe controller device (e.g. /dev/nvme0)
 * @error: (out): place to store error (if any)
 *
 * Retrieves drive SMART and general health information (Log Identifier %02h).
 * The information provided is over the life of the controller and is retained across power cycles.
 *
 * Returns: (transfer full): health log data or %NULL in case of an error (with @error set).
 *
 * Tech category: %BD_NVME_TECH_NVME-%BD_NVME_TECH_MODE_INFO
 */
BDNVMESmartLog * bd_nvme_get_smart_log (const gchar *device, GError **error);

/**
 * bd_nvme_get_error_log_entries:
 * @device: a NVMe controller device (e.g. /dev/nvme0)
 * @error: (out): place to store error (if any)
 *
 * Retrieves Error Information Log (Log Identifier %01h) entries, used to describe
 * extended error information for a command that completed with error or to report
 * an error that is not specific to a particular command. This log is global to the
 * controller. The ordering of the entries is based on the time when the error
 * occurred, with the most recent error being returned as the first log entry.
 * As the number of entries is typically limited by the drive implementation, only
 * most recent entries are provided.
 *
 * Returns: (transfer full) (array zero-terminated=1) (element-type BDNVMEErrorLogEntry):
 *          null-terminated list of error entries or %NULL in case of an error (with @error set).
 *
 * Tech category: %BD_NVME_TECH_NVME-%BD_NVME_TECH_MODE_INFO
 */
BDNVMEErrorLogEntry ** bd_nvme_get_error_log_entries (const gchar *device, GError **error);


#endif  /* BD_NVME_API */
